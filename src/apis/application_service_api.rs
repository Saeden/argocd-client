/*
 * Consolidate Services
 *
 * Description of all APIs
 *
 * The version of the OpenAPI document: version not set
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`application_service_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceCreateError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceDeleteError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_delete_resource`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceDeleteResourceError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceGetError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_get_application_sync_windows`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceGetApplicationSyncWindowsError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_get_manifests`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceGetManifestsError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_get_manifests_with_files`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceGetManifestsWithFilesError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_get_oci_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceGetOciMetadataError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_get_resource`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceGetResourceError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceListError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_list_links`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceListLinksError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_list_resource_actions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceListResourceActionsError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_list_resource_events`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceListResourceEventsError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_list_resource_links`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceListResourceLinksError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_managed_resources`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceManagedResourcesError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServicePatchError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_patch_resource`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServicePatchResourceError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_pod_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServicePodLogsError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_pod_logs2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServicePodLogs2Error {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_resource_tree`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceResourceTreeError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_revision_chart_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceRevisionChartDetailsError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_revision_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceRevisionMetadataError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_rollback`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceRollbackError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_run_resource_action`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceRunResourceActionError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_run_resource_action_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceRunResourceActionV2Error {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_sync`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceSyncError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_terminate_operation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceTerminateOperationError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceUpdateError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_update_spec`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceUpdateSpecError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_watch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceWatchError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`application_service_watch_resource_tree`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationServiceWatchResourceTreeError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

pub async fn application_service_create(
    configuration: &configuration::Configuration,
    body: models::V1alpha1Application,
    upsert: Option<bool>,
    validate: Option<bool>,
) -> Result<models::V1alpha1Application, Error<ApplicationServiceCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_query_upsert = upsert;
    let p_query_validate = validate;

    let uri_str = format!("{}/api/v1/applications", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_upsert {
        req_builder = req_builder.query(&[("upsert", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_validate {
        req_builder = req_builder.query(&[("validate", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::V1alpha1Application`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1Application`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_delete(
    configuration: &configuration::Configuration,
    name: &str,
    cascade: Option<bool>,
    propagation_policy: Option<&str>,
    app_namespace: Option<&str>,
    project: Option<&str>,
) -> Result<serde_json::Value, Error<ApplicationServiceDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_cascade = cascade;
    let p_query_propagation_policy = propagation_policy;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/applications/{name}",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_cascade {
        req_builder = req_builder.query(&[("cascade", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_propagation_policy {
        req_builder = req_builder.query(&[("propagationPolicy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_delete_resource(
    configuration: &configuration::Configuration,
    name: &str,
    namespace: Option<&str>,
    resource_name: Option<&str>,
    version: Option<&str>,
    group: Option<&str>,
    kind: Option<&str>,
    force: Option<bool>,
    orphan: Option<bool>,
    app_namespace: Option<&str>,
    project: Option<&str>,
) -> Result<serde_json::Value, Error<ApplicationServiceDeleteResourceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_namespace = namespace;
    let p_query_resource_name = resource_name;
    let p_query_version = version;
    let p_query_group = group;
    let p_query_kind = kind;
    let p_query_force = force;
    let p_query_orphan = orphan;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/resource",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_namespace {
        req_builder = req_builder.query(&[("namespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_resource_name {
        req_builder = req_builder.query(&[("resourceName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_kind {
        req_builder = req_builder.query(&[("kind", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force {
        req_builder = req_builder.query(&[("force", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_orphan {
        req_builder = req_builder.query(&[("orphan", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceDeleteResourceError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_get(
    configuration: &configuration::Configuration,
    name: &str,
    refresh: Option<&str>,
    projects: Option<Vec<String>>,
    resource_version: Option<&str>,
    selector: Option<&str>,
    repo: Option<&str>,
    app_namespace: Option<&str>,
    project: Option<Vec<String>>,
) -> Result<models::V1alpha1Application, Error<ApplicationServiceGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_refresh = refresh;
    let p_query_projects = projects;
    let p_query_resource_version = resource_version;
    let p_query_selector = selector;
    let p_query_repo = repo;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/applications/{name}",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_refresh {
        req_builder = req_builder.query(&[("refresh", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_projects {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("projects".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "projects",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_resource_version {
        req_builder = req_builder.query(&[("resourceVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_selector {
        req_builder = req_builder.query(&[("selector", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_repo {
        req_builder = req_builder.query(&[("repo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("project".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "project",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::V1alpha1Application`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1Application`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_get_application_sync_windows(
    configuration: &configuration::Configuration,
    name: &str,
    app_namespace: Option<&str>,
    project: Option<&str>,
) -> Result<
    models::ApplicationApplicationSyncWindowsResponse,
    Error<ApplicationServiceGetApplicationSyncWindowsError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/syncwindows",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationApplicationSyncWindowsResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationApplicationSyncWindowsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceGetApplicationSyncWindowsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_get_manifests(
    configuration: &configuration::Configuration,
    name: &str,
    revision: Option<&str>,
    app_namespace: Option<&str>,
    project: Option<&str>,
    source_positions: Option<Vec<String>>,
    revisions: Option<Vec<String>>,
) -> Result<models::RepositoryManifestResponse, Error<ApplicationServiceGetManifestsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_revision = revision;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;
    let p_query_source_positions = source_positions;
    let p_query_revisions = revisions;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/manifests",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_revision {
        req_builder = req_builder.query(&[("revision", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source_positions {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("sourcePositions".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "sourcePositions",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_revisions {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("revisions".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "revisions",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RepositoryManifestResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RepositoryManifestResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceGetManifestsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_get_manifests_with_files(
    configuration: &configuration::Configuration,
    body: models::ApplicationApplicationManifestQueryWithFilesWrapper,
) -> Result<models::RepositoryManifestResponse, Error<ApplicationServiceGetManifestsWithFilesError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;

    let uri_str = format!(
        "{}/api/v1/applications/manifestsWithFiles",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RepositoryManifestResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RepositoryManifestResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceGetManifestsWithFilesError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_get_oci_metadata(
    configuration: &configuration::Configuration,
    name: &str,
    revision: &str,
    app_namespace: Option<&str>,
    project: Option<&str>,
    source_index: Option<i32>,
    version_id: Option<i32>,
) -> Result<models::V1alpha1OciMetadata, Error<ApplicationServiceGetOciMetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_path_revision = revision;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;
    let p_query_source_index = source_index;
    let p_query_version_id = version_id;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/revisions/{revision}/ocimetadata",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name),
        revision = crate::apis::urlencode(p_path_revision)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source_index {
        req_builder = req_builder.query(&[("sourceIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version_id {
        req_builder = req_builder.query(&[("versionId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::V1alpha1OciMetadata`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1OciMetadata`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceGetOciMetadataError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_get_resource(
    configuration: &configuration::Configuration,
    name: &str,
    namespace: Option<&str>,
    resource_name: Option<&str>,
    version: Option<&str>,
    group: Option<&str>,
    kind: Option<&str>,
    app_namespace: Option<&str>,
    project: Option<&str>,
) -> Result<models::ApplicationApplicationResourceResponse, Error<ApplicationServiceGetResourceError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_namespace = namespace;
    let p_query_resource_name = resource_name;
    let p_query_version = version;
    let p_query_group = group;
    let p_query_kind = kind;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/resource",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_namespace {
        req_builder = req_builder.query(&[("namespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_resource_name {
        req_builder = req_builder.query(&[("resourceName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_kind {
        req_builder = req_builder.query(&[("kind", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationApplicationResourceResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationApplicationResourceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceGetResourceError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_list(
    configuration: &configuration::Configuration,
    name: Option<&str>,
    refresh: Option<&str>,
    projects: Option<Vec<String>>,
    resource_version: Option<&str>,
    selector: Option<&str>,
    repo: Option<&str>,
    app_namespace: Option<&str>,
    project: Option<Vec<String>>,
) -> Result<models::V1alpha1ApplicationList, Error<ApplicationServiceListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_name = name;
    let p_query_refresh = refresh;
    let p_query_projects = projects;
    let p_query_resource_version = resource_version;
    let p_query_selector = selector;
    let p_query_repo = repo;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!("{}/api/v1/applications", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_refresh {
        req_builder = req_builder.query(&[("refresh", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_projects {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("projects".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "projects",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_resource_version {
        req_builder = req_builder.query(&[("resourceVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_selector {
        req_builder = req_builder.query(&[("selector", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_repo {
        req_builder = req_builder.query(&[("repo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("project".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "project",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::V1alpha1ApplicationList`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1ApplicationList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_list_links(
    configuration: &configuration::Configuration,
    name: &str,
    namespace: Option<&str>,
    project: Option<&str>,
) -> Result<models::ApplicationLinksResponse, Error<ApplicationServiceListLinksError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_namespace = namespace;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/links",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_namespace {
        req_builder = req_builder.query(&[("namespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationLinksResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationLinksResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceListLinksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_list_resource_actions(
    configuration: &configuration::Configuration,
    name: &str,
    namespace: Option<&str>,
    resource_name: Option<&str>,
    version: Option<&str>,
    group: Option<&str>,
    kind: Option<&str>,
    app_namespace: Option<&str>,
    project: Option<&str>,
) -> Result<
    models::ApplicationResourceActionsListResponse,
    Error<ApplicationServiceListResourceActionsError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_namespace = namespace;
    let p_query_resource_name = resource_name;
    let p_query_version = version;
    let p_query_group = group;
    let p_query_kind = kind;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/resource/actions",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_namespace {
        req_builder = req_builder.query(&[("namespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_resource_name {
        req_builder = req_builder.query(&[("resourceName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_kind {
        req_builder = req_builder.query(&[("kind", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationResourceActionsListResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationResourceActionsListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceListResourceActionsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_list_resource_events(
    configuration: &configuration::Configuration,
    name: &str,
    resource_namespace: Option<&str>,
    resource_name: Option<&str>,
    resource_uid: Option<&str>,
    app_namespace: Option<&str>,
    project: Option<&str>,
) -> Result<models::V1EventList, Error<ApplicationServiceListResourceEventsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_resource_namespace = resource_namespace;
    let p_query_resource_name = resource_name;
    let p_query_resource_uid = resource_uid;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/events",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_resource_namespace {
        req_builder = req_builder.query(&[("resourceNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_resource_name {
        req_builder = req_builder.query(&[("resourceName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_resource_uid {
        req_builder = req_builder.query(&[("resourceUID", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::V1EventList`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::V1EventList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceListResourceEventsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_list_resource_links(
    configuration: &configuration::Configuration,
    name: &str,
    namespace: Option<&str>,
    resource_name: Option<&str>,
    version: Option<&str>,
    group: Option<&str>,
    kind: Option<&str>,
    app_namespace: Option<&str>,
    project: Option<&str>,
) -> Result<models::ApplicationLinksResponse, Error<ApplicationServiceListResourceLinksError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_namespace = namespace;
    let p_query_resource_name = resource_name;
    let p_query_version = version;
    let p_query_group = group;
    let p_query_kind = kind;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/resource/links",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_namespace {
        req_builder = req_builder.query(&[("namespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_resource_name {
        req_builder = req_builder.query(&[("resourceName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_kind {
        req_builder = req_builder.query(&[("kind", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationLinksResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationLinksResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceListResourceLinksError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_managed_resources(
    configuration: &configuration::Configuration,
    application_name: &str,
    namespace: Option<&str>,
    name: Option<&str>,
    version: Option<&str>,
    group: Option<&str>,
    kind: Option<&str>,
    app_namespace: Option<&str>,
    project: Option<&str>,
) -> Result<
    models::ApplicationManagedResourcesResponse,
    Error<ApplicationServiceManagedResourcesError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_name = application_name;
    let p_query_namespace = namespace;
    let p_query_name = name;
    let p_query_version = version;
    let p_query_group = group;
    let p_query_kind = kind;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/applications/{applicationName}/managed-resources",
        configuration.base_path,
        applicationName = crate::apis::urlencode(p_path_application_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_namespace {
        req_builder = req_builder.query(&[("namespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_kind {
        req_builder = req_builder.query(&[("kind", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationManagedResourcesResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationManagedResourcesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceManagedResourcesError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_patch(
    configuration: &configuration::Configuration,
    body: models::ApplicationApplicationPatchRequest,
    name: &str,
) -> Result<models::V1alpha1Application, Error<ApplicationServicePatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_name = name;

    let uri_str = format!(
        "{}/api/v1/applications/{name}",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::V1alpha1Application`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1Application`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServicePatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_patch_resource(
    configuration: &configuration::Configuration,
    body: &str,
    name: &str,
    namespace: Option<&str>,
    resource_name: Option<&str>,
    version: Option<&str>,
    group: Option<&str>,
    kind: Option<&str>,
    patch_type: Option<&str>,
    app_namespace: Option<&str>,
    project: Option<&str>,
) -> Result<
    models::ApplicationApplicationResourceResponse,
    Error<ApplicationServicePatchResourceError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_name = name;
    let p_query_namespace = namespace;
    let p_query_resource_name = resource_name;
    let p_query_version = version;
    let p_query_group = group;
    let p_query_kind = kind;
    let p_query_patch_type = patch_type;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/resource",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_namespace {
        req_builder = req_builder.query(&[("namespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_resource_name {
        req_builder = req_builder.query(&[("resourceName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_kind {
        req_builder = req_builder.query(&[("kind", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_patch_type {
        req_builder = req_builder.query(&[("patchType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationApplicationResourceResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationApplicationResourceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServicePatchResourceError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_pod_logs(
    configuration: &configuration::Configuration,
    name: &str,
    pod_name: &str,
    namespace: Option<&str>,
    container: Option<&str>,
    since_seconds: Option<&str>,
    since_time_seconds: Option<&str>,
    since_time_nanos: Option<i32>,
    tail_lines: Option<&str>,
    follow: Option<bool>,
    until_time: Option<&str>,
    filter: Option<&str>,
    kind: Option<&str>,
    group: Option<&str>,
    resource_name: Option<&str>,
    previous: Option<bool>,
    app_namespace: Option<&str>,
    project: Option<&str>,
    match_case: Option<bool>,
) -> Result<models::StreamResultOfApplicationLogEntry, Error<ApplicationServicePodLogsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_path_pod_name = pod_name;
    let p_query_namespace = namespace;
    let p_query_container = container;
    let p_query_since_seconds = since_seconds;
    let p_query_since_time_seconds = since_time_seconds;
    let p_query_since_time_nanos = since_time_nanos;
    let p_query_tail_lines = tail_lines;
    let p_query_follow = follow;
    let p_query_until_time = until_time;
    let p_query_filter = filter;
    let p_query_kind = kind;
    let p_query_group = group;
    let p_query_resource_name = resource_name;
    let p_query_previous = previous;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;
    let p_query_match_case = match_case;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/pods/{podName}/logs",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name),
        podName = crate::apis::urlencode(p_path_pod_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_namespace {
        req_builder = req_builder.query(&[("namespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_container {
        req_builder = req_builder.query(&[("container", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_since_seconds {
        req_builder = req_builder.query(&[("sinceSeconds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_since_time_seconds {
        req_builder = req_builder.query(&[("sinceTime.seconds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_since_time_nanos {
        req_builder = req_builder.query(&[("sinceTime.nanos", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tail_lines {
        req_builder = req_builder.query(&[("tailLines", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_follow {
        req_builder = req_builder.query(&[("follow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_until_time {
        req_builder = req_builder.query(&[("untilTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_kind {
        req_builder = req_builder.query(&[("kind", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_resource_name {
        req_builder = req_builder.query(&[("resourceName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous {
        req_builder = req_builder.query(&[("previous", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_match_case {
        req_builder = req_builder.query(&[("matchCase", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StreamResultOfApplicationLogEntry`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StreamResultOfApplicationLogEntry`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServicePodLogsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_pod_logs2(
    configuration: &configuration::Configuration,
    name: &str,
    namespace: Option<&str>,
    pod_name: Option<&str>,
    container: Option<&str>,
    since_seconds: Option<&str>,
    since_time_seconds: Option<&str>,
    since_time_nanos: Option<i32>,
    tail_lines: Option<&str>,
    follow: Option<bool>,
    until_time: Option<&str>,
    filter: Option<&str>,
    kind: Option<&str>,
    group: Option<&str>,
    resource_name: Option<&str>,
    previous: Option<bool>,
    app_namespace: Option<&str>,
    project: Option<&str>,
    match_case: Option<bool>,
) -> Result<models::StreamResultOfApplicationLogEntry, Error<ApplicationServicePodLogs2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_namespace = namespace;
    let p_query_pod_name = pod_name;
    let p_query_container = container;
    let p_query_since_seconds = since_seconds;
    let p_query_since_time_seconds = since_time_seconds;
    let p_query_since_time_nanos = since_time_nanos;
    let p_query_tail_lines = tail_lines;
    let p_query_follow = follow;
    let p_query_until_time = until_time;
    let p_query_filter = filter;
    let p_query_kind = kind;
    let p_query_group = group;
    let p_query_resource_name = resource_name;
    let p_query_previous = previous;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;
    let p_query_match_case = match_case;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/logs",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_namespace {
        req_builder = req_builder.query(&[("namespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_pod_name {
        req_builder = req_builder.query(&[("podName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_container {
        req_builder = req_builder.query(&[("container", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_since_seconds {
        req_builder = req_builder.query(&[("sinceSeconds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_since_time_seconds {
        req_builder = req_builder.query(&[("sinceTime.seconds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_since_time_nanos {
        req_builder = req_builder.query(&[("sinceTime.nanos", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tail_lines {
        req_builder = req_builder.query(&[("tailLines", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_follow {
        req_builder = req_builder.query(&[("follow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_until_time {
        req_builder = req_builder.query(&[("untilTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_kind {
        req_builder = req_builder.query(&[("kind", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_resource_name {
        req_builder = req_builder.query(&[("resourceName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous {
        req_builder = req_builder.query(&[("previous", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_match_case {
        req_builder = req_builder.query(&[("matchCase", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StreamResultOfApplicationLogEntry`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StreamResultOfApplicationLogEntry`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServicePodLogs2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_resource_tree(
    configuration: &configuration::Configuration,
    application_name: &str,
    namespace: Option<&str>,
    name: Option<&str>,
    version: Option<&str>,
    group: Option<&str>,
    kind: Option<&str>,
    app_namespace: Option<&str>,
    project: Option<&str>,
) -> Result<models::V1alpha1ApplicationTree, Error<ApplicationServiceResourceTreeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_name = application_name;
    let p_query_namespace = namespace;
    let p_query_name = name;
    let p_query_version = version;
    let p_query_group = group;
    let p_query_kind = kind;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/applications/{applicationName}/resource-tree",
        configuration.base_path,
        applicationName = crate::apis::urlencode(p_path_application_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_namespace {
        req_builder = req_builder.query(&[("namespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_kind {
        req_builder = req_builder.query(&[("kind", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::V1alpha1ApplicationTree`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1ApplicationTree`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceResourceTreeError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_revision_chart_details(
    configuration: &configuration::Configuration,
    name: &str,
    revision: &str,
    app_namespace: Option<&str>,
    project: Option<&str>,
    source_index: Option<i32>,
    version_id: Option<i32>,
) -> Result<models::V1alpha1ChartDetails, Error<ApplicationServiceRevisionChartDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_path_revision = revision;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;
    let p_query_source_index = source_index;
    let p_query_version_id = version_id;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/revisions/{revision}/chartdetails",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name),
        revision = crate::apis::urlencode(p_path_revision)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source_index {
        req_builder = req_builder.query(&[("sourceIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version_id {
        req_builder = req_builder.query(&[("versionId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::V1alpha1ChartDetails`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1ChartDetails`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceRevisionChartDetailsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_revision_metadata(
    configuration: &configuration::Configuration,
    name: &str,
    revision: &str,
    app_namespace: Option<&str>,
    project: Option<&str>,
    source_index: Option<i32>,
    version_id: Option<i32>,
) -> Result<models::V1alpha1RevisionMetadata, Error<ApplicationServiceRevisionMetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_path_revision = revision;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;
    let p_query_source_index = source_index;
    let p_query_version_id = version_id;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/revisions/{revision}/metadata",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name),
        revision = crate::apis::urlencode(p_path_revision)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source_index {
        req_builder = req_builder.query(&[("sourceIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version_id {
        req_builder = req_builder.query(&[("versionId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::V1alpha1RevisionMetadata`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1RevisionMetadata`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceRevisionMetadataError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_rollback(
    configuration: &configuration::Configuration,
    body: models::ApplicationApplicationRollbackRequest,
    name: &str,
) -> Result<models::V1alpha1Application, Error<ApplicationServiceRollbackError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_name = name;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/rollback",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::V1alpha1Application`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1Application`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceRollbackError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Deprecated: use RunResourceActionV2 instead. This version does not support resource action parameters but is maintained for backward compatibility. It will be removed in a future release.
pub async fn application_service_run_resource_action(
    configuration: &configuration::Configuration,
    body: &str,
    name: &str,
    namespace: Option<&str>,
    resource_name: Option<&str>,
    version: Option<&str>,
    group: Option<&str>,
    kind: Option<&str>,
    app_namespace: Option<&str>,
    project: Option<&str>,
) -> Result<serde_json::Value, Error<ApplicationServiceRunResourceActionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_name = name;
    let p_query_namespace = namespace;
    let p_query_resource_name = resource_name;
    let p_query_version = version;
    let p_query_group = group;
    let p_query_kind = kind;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/resource/actions",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_namespace {
        req_builder = req_builder.query(&[("namespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_resource_name {
        req_builder = req_builder.query(&[("resourceName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_kind {
        req_builder = req_builder.query(&[("kind", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceRunResourceActionError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_run_resource_action_v2(
    configuration: &configuration::Configuration,
    body: models::ApplicationResourceActionRunRequestV2,
    name: &str,
) -> Result<serde_json::Value, Error<ApplicationServiceRunResourceActionV2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_name = name;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/resource/actions/v2",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceRunResourceActionV2Error> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_sync(
    configuration: &configuration::Configuration,
    body: models::ApplicationApplicationSyncRequest,
    name: &str,
) -> Result<models::V1alpha1Application, Error<ApplicationServiceSyncError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_name = name;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/sync",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::V1alpha1Application`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1Application`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceSyncError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_terminate_operation(
    configuration: &configuration::Configuration,
    name: &str,
    app_namespace: Option<&str>,
    project: Option<&str>,
) -> Result<serde_json::Value, Error<ApplicationServiceTerminateOperationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/operation",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceTerminateOperationError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_update(
    configuration: &configuration::Configuration,
    body: models::V1alpha1Application,
    application_metadata_name: &str,
    validate: Option<bool>,
    project: Option<&str>,
) -> Result<models::V1alpha1Application, Error<ApplicationServiceUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_application_metadata_name = application_metadata_name;
    let p_query_validate = validate;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/applications/{}",
        configuration.base_path,
        crate::apis::urlencode(p_path_application_metadata_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_validate {
        req_builder = req_builder.query(&[("validate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::V1alpha1Application`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1Application`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_update_spec(
    configuration: &configuration::Configuration,
    body: models::V1alpha1ApplicationSpec,
    name: &str,
    validate: Option<bool>,
    app_namespace: Option<&str>,
    project: Option<&str>,
) -> Result<models::V1alpha1ApplicationSpec, Error<ApplicationServiceUpdateSpecError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_name = name;
    let p_query_validate = validate;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/applications/{name}/spec",
        configuration.base_path,
        name = crate::apis::urlencode(p_path_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_validate {
        req_builder = req_builder.query(&[("validate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::V1alpha1ApplicationSpec`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1ApplicationSpec`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceUpdateSpecError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_watch(
    configuration: &configuration::Configuration,
    name: Option<&str>,
    refresh: Option<&str>,
    projects: Option<Vec<String>>,
    resource_version: Option<&str>,
    selector: Option<&str>,
    repo: Option<&str>,
    app_namespace: Option<&str>,
    project: Option<Vec<String>>,
) -> Result<models::StreamResultOfV1alpha1ApplicationWatchEvent, Error<ApplicationServiceWatchError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_name = name;
    let p_query_refresh = refresh;
    let p_query_projects = projects;
    let p_query_resource_version = resource_version;
    let p_query_selector = selector;
    let p_query_repo = repo;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!("{}/api/v1/stream/applications", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_refresh {
        req_builder = req_builder.query(&[("refresh", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_projects {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("projects".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "projects",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_resource_version {
        req_builder = req_builder.query(&[("resourceVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_selector {
        req_builder = req_builder.query(&[("selector", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_repo {
        req_builder = req_builder.query(&[("repo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("project".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "project",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StreamResultOfV1alpha1ApplicationWatchEvent`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StreamResultOfV1alpha1ApplicationWatchEvent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceWatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn application_service_watch_resource_tree(
    configuration: &configuration::Configuration,
    application_name: &str,
    namespace: Option<&str>,
    name: Option<&str>,
    version: Option<&str>,
    group: Option<&str>,
    kind: Option<&str>,
    app_namespace: Option<&str>,
    project: Option<&str>,
) -> Result<
    models::StreamResultOfV1alpha1ApplicationTree,
    Error<ApplicationServiceWatchResourceTreeError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_name = application_name;
    let p_query_namespace = namespace;
    let p_query_name = name;
    let p_query_version = version;
    let p_query_group = group;
    let p_query_kind = kind;
    let p_query_app_namespace = app_namespace;
    let p_query_project = project;

    let uri_str = format!(
        "{}/api/v1/stream/applications/{applicationName}/resource-tree",
        configuration.base_path,
        applicationName = crate::apis::urlencode(p_path_application_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_namespace {
        req_builder = req_builder.query(&[("namespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_kind {
        req_builder = req_builder.query(&[("kind", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_namespace {
        req_builder = req_builder.query(&[("appNamespace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StreamResultOfV1alpha1ApplicationTree`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StreamResultOfV1alpha1ApplicationTree`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplicationServiceWatchResourceTreeError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
