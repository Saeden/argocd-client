/*
 * Consolidate Services
 *
 * Description of all APIs
 *
 * The version of the OpenAPI document: version not set
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`repository_service_create_repository`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceCreateRepositoryError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repository_service_create_write_repository`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceCreateWriteRepositoryError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repository_service_delete_repository`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceDeleteRepositoryError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repository_service_delete_write_repository`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceDeleteWriteRepositoryError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repository_service_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceGetError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repository_service_get_app_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceGetAppDetailsError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repository_service_get_helm_charts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceGetHelmChartsError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repository_service_get_write`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceGetWriteError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repository_service_list_apps`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceListAppsError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repository_service_list_oci_tags`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceListOciTagsError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repository_service_list_refs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceListRefsError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repository_service_list_repositories`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceListRepositoriesError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repository_service_list_write_repositories`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceListWriteRepositoriesError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repository_service_update_repository`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceUpdateRepositoryError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repository_service_update_write_repository`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceUpdateWriteRepositoryError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repository_service_validate_access`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceValidateAccessError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repository_service_validate_write_access`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryServiceValidateWriteAccessError {
    DefaultResponse(models::RuntimeError),
    UnknownValue(serde_json::Value),
}

pub async fn repository_service_create_repository(
    configuration: &configuration::Configuration,
    body: models::V1alpha1Repository,
    upsert: Option<bool>,
    creds_only: Option<bool>,
) -> Result<models::V1alpha1Repository, Error<RepositoryServiceCreateRepositoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_query_upsert = upsert;
    let p_query_creds_only = creds_only;

    let uri_str = format!("{}/api/v1/repositories", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_upsert {
        req_builder = req_builder.query(&[("upsert", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_creds_only {
        req_builder = req_builder.query(&[("credsOnly", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::V1alpha1Repository`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1Repository`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceCreateRepositoryError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn repository_service_create_write_repository(
    configuration: &configuration::Configuration,
    body: models::V1alpha1Repository,
    upsert: Option<bool>,
    creds_only: Option<bool>,
) -> Result<models::V1alpha1Repository, Error<RepositoryServiceCreateWriteRepositoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_query_upsert = upsert;
    let p_query_creds_only = creds_only;

    let uri_str = format!("{}/api/v1/write-repositories", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_upsert {
        req_builder = req_builder.query(&[("upsert", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_creds_only {
        req_builder = req_builder.query(&[("credsOnly", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::V1alpha1Repository`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1Repository`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceCreateWriteRepositoryError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn repository_service_delete_repository(
    configuration: &configuration::Configuration,
    repo: &str,
    force_refresh: Option<bool>,
    app_project: Option<&str>,
) -> Result<serde_json::Value, Error<RepositoryServiceDeleteRepositoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo = repo;
    let p_query_force_refresh = force_refresh;
    let p_query_app_project = app_project;

    let uri_str = format!(
        "{}/api/v1/repositories/{repo}",
        configuration.base_path,
        repo = crate::apis::urlencode(p_path_repo)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_force_refresh {
        req_builder = req_builder.query(&[("forceRefresh", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_project {
        req_builder = req_builder.query(&[("appProject", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceDeleteRepositoryError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn repository_service_delete_write_repository(
    configuration: &configuration::Configuration,
    repo: &str,
    force_refresh: Option<bool>,
    app_project: Option<&str>,
) -> Result<serde_json::Value, Error<RepositoryServiceDeleteWriteRepositoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo = repo;
    let p_query_force_refresh = force_refresh;
    let p_query_app_project = app_project;

    let uri_str = format!(
        "{}/api/v1/write-repositories/{repo}",
        configuration.base_path,
        repo = crate::apis::urlencode(p_path_repo)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_force_refresh {
        req_builder = req_builder.query(&[("forceRefresh", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_project {
        req_builder = req_builder.query(&[("appProject", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceDeleteWriteRepositoryError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn repository_service_get(
    configuration: &configuration::Configuration,
    repo: &str,
    force_refresh: Option<bool>,
    app_project: Option<&str>,
) -> Result<models::V1alpha1Repository, Error<RepositoryServiceGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo = repo;
    let p_query_force_refresh = force_refresh;
    let p_query_app_project = app_project;

    let uri_str = format!(
        "{}/api/v1/repositories/{repo}",
        configuration.base_path,
        repo = crate::apis::urlencode(p_path_repo)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_force_refresh {
        req_builder = req_builder.query(&[("forceRefresh", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_project {
        req_builder = req_builder.query(&[("appProject", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::V1alpha1Repository`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1Repository`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn repository_service_get_app_details(
    configuration: &configuration::Configuration,
    body: models::RepositoryRepoAppDetailsQuery,
    source_repo_url: &str,
) -> Result<models::RepositoryRepoAppDetailsResponse, Error<RepositoryServiceGetAppDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_source_repo_url = source_repo_url;

    let uri_str = format!(
        "{}/api/v1/repositories/{}/appdetails",
        configuration.base_path,
        crate::apis::urlencode(p_path_source_repo_url)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::RepositoryRepoAppDetailsResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::RepositoryRepoAppDetailsResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceGetAppDetailsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn repository_service_get_helm_charts(
    configuration: &configuration::Configuration,
    repo: &str,
    force_refresh: Option<bool>,
    app_project: Option<&str>,
) -> Result<models::RepositoryHelmChartsResponse, Error<RepositoryServiceGetHelmChartsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo = repo;
    let p_query_force_refresh = force_refresh;
    let p_query_app_project = app_project;

    let uri_str = format!(
        "{}/api/v1/repositories/{repo}/helmcharts",
        configuration.base_path,
        repo = crate::apis::urlencode(p_path_repo)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_force_refresh {
        req_builder = req_builder.query(&[("forceRefresh", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_project {
        req_builder = req_builder.query(&[("appProject", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::RepositoryHelmChartsResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::RepositoryHelmChartsResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceGetHelmChartsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn repository_service_get_write(
    configuration: &configuration::Configuration,
    repo: &str,
    force_refresh: Option<bool>,
    app_project: Option<&str>,
) -> Result<models::V1alpha1Repository, Error<RepositoryServiceGetWriteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo = repo;
    let p_query_force_refresh = force_refresh;
    let p_query_app_project = app_project;

    let uri_str = format!(
        "{}/api/v1/write-repositories/{repo}",
        configuration.base_path,
        repo = crate::apis::urlencode(p_path_repo)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_force_refresh {
        req_builder = req_builder.query(&[("forceRefresh", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_project {
        req_builder = req_builder.query(&[("appProject", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::V1alpha1Repository`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1Repository`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceGetWriteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn repository_service_list_apps(
    configuration: &configuration::Configuration,
    repo: &str,
    revision: Option<&str>,
    app_name: Option<&str>,
    app_project: Option<&str>,
) -> Result<models::RepositoryRepoAppsResponse, Error<RepositoryServiceListAppsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo = repo;
    let p_query_revision = revision;
    let p_query_app_name = app_name;
    let p_query_app_project = app_project;

    let uri_str = format!(
        "{}/api/v1/repositories/{repo}/apps",
        configuration.base_path,
        repo = crate::apis::urlencode(p_path_repo)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_revision {
        req_builder = req_builder.query(&[("revision", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_name {
        req_builder = req_builder.query(&[("appName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_project {
        req_builder = req_builder.query(&[("appProject", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::RepositoryRepoAppsResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::RepositoryRepoAppsResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceListAppsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn repository_service_list_oci_tags(
    configuration: &configuration::Configuration,
    repo: &str,
    force_refresh: Option<bool>,
    app_project: Option<&str>,
) -> Result<models::RepositoryRefs, Error<RepositoryServiceListOciTagsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo = repo;
    let p_query_force_refresh = force_refresh;
    let p_query_app_project = app_project;

    let uri_str = format!(
        "{}/api/v1/repositories/{repo}/oci-tags",
        configuration.base_path,
        repo = crate::apis::urlencode(p_path_repo)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_force_refresh {
        req_builder = req_builder.query(&[("forceRefresh", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_project {
        req_builder = req_builder.query(&[("appProject", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::RepositoryRefs`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::RepositoryRefs`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceListOciTagsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn repository_service_list_refs(
    configuration: &configuration::Configuration,
    repo: &str,
    force_refresh: Option<bool>,
    app_project: Option<&str>,
) -> Result<models::RepositoryRefs, Error<RepositoryServiceListRefsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_repo = repo;
    let p_query_force_refresh = force_refresh;
    let p_query_app_project = app_project;

    let uri_str = format!(
        "{}/api/v1/repositories/{repo}/refs",
        configuration.base_path,
        repo = crate::apis::urlencode(p_path_repo)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_force_refresh {
        req_builder = req_builder.query(&[("forceRefresh", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_project {
        req_builder = req_builder.query(&[("appProject", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::RepositoryRefs`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::RepositoryRefs`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceListRefsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn repository_service_list_repositories(
    configuration: &configuration::Configuration,
    repo: Option<&str>,
    force_refresh: Option<bool>,
    app_project: Option<&str>,
) -> Result<models::V1alpha1RepositoryList, Error<RepositoryServiceListRepositoriesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_repo = repo;
    let p_query_force_refresh = force_refresh;
    let p_query_app_project = app_project;

    let uri_str = format!("{}/api/v1/repositories", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_repo {
        req_builder = req_builder.query(&[("repo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_refresh {
        req_builder = req_builder.query(&[("forceRefresh", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_project {
        req_builder = req_builder.query(&[("appProject", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::V1alpha1RepositoryList`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1RepositoryList`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceListRepositoriesError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn repository_service_list_write_repositories(
    configuration: &configuration::Configuration,
    repo: Option<&str>,
    force_refresh: Option<bool>,
    app_project: Option<&str>,
) -> Result<models::V1alpha1RepositoryList, Error<RepositoryServiceListWriteRepositoriesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_repo = repo;
    let p_query_force_refresh = force_refresh;
    let p_query_app_project = app_project;

    let uri_str = format!("{}/api/v1/write-repositories", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_repo {
        req_builder = req_builder.query(&[("repo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_refresh {
        req_builder = req_builder.query(&[("forceRefresh", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_project {
        req_builder = req_builder.query(&[("appProject", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::V1alpha1RepositoryList`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1RepositoryList`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceListWriteRepositoriesError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn repository_service_update_repository(
    configuration: &configuration::Configuration,
    body: models::V1alpha1Repository,
    repo_repo: &str,
) -> Result<models::V1alpha1Repository, Error<RepositoryServiceUpdateRepositoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_repo_repo = repo_repo;

    let uri_str = format!(
        "{}/api/v1/repositories/{}",
        configuration.base_path,
        crate::apis::urlencode(p_path_repo_repo)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::V1alpha1Repository`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1Repository`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceUpdateRepositoryError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn repository_service_update_write_repository(
    configuration: &configuration::Configuration,
    body: models::V1alpha1Repository,
    repo_repo: &str,
) -> Result<models::V1alpha1Repository, Error<RepositoryServiceUpdateWriteRepositoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_repo_repo = repo_repo;

    let uri_str = format!(
        "{}/api/v1/write-repositories/{}",
        configuration.base_path,
        crate::apis::urlencode(p_path_repo_repo)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::V1alpha1Repository`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::V1alpha1Repository`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceUpdateWriteRepositoryError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn repository_service_validate_access(
    configuration: &configuration::Configuration,
    body: &str,
    repo: &str,
    username: Option<&str>,
    password: Option<&str>,
    ssh_private_key: Option<&str>,
    insecure: Option<bool>,
    tls_client_cert_data: Option<&str>,
    tls_client_cert_key: Option<&str>,
    r#type: Option<&str>,
    name: Option<&str>,
    enable_oci: Option<bool>,
    github_app_private_key: Option<&str>,
    github_app_id: Option<&str>,
    github_app_installation_id: Option<&str>,
    github_app_enterprise_base_url: Option<&str>,
    proxy: Option<&str>,
    project: Option<&str>,
    gcp_service_account_key: Option<&str>,
    force_http_basic_auth: Option<bool>,
    use_azure_workload_identity: Option<bool>,
    bearer_token: Option<&str>,
    insecure_oci_force_http: Option<bool>,
) -> Result<serde_json::Value, Error<RepositoryServiceValidateAccessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_repo = repo;
    let p_query_username = username;
    let p_query_password = password;
    let p_query_ssh_private_key = ssh_private_key;
    let p_query_insecure = insecure;
    let p_query_tls_client_cert_data = tls_client_cert_data;
    let p_query_tls_client_cert_key = tls_client_cert_key;
    let p_query_type = r#type;
    let p_query_name = name;
    let p_query_enable_oci = enable_oci;
    let p_query_github_app_private_key = github_app_private_key;
    let p_query_github_app_id = github_app_id;
    let p_query_github_app_installation_id = github_app_installation_id;
    let p_query_github_app_enterprise_base_url = github_app_enterprise_base_url;
    let p_query_proxy = proxy;
    let p_query_project = project;
    let p_query_gcp_service_account_key = gcp_service_account_key;
    let p_query_force_http_basic_auth = force_http_basic_auth;
    let p_query_use_azure_workload_identity = use_azure_workload_identity;
    let p_query_bearer_token = bearer_token;
    let p_query_insecure_oci_force_http = insecure_oci_force_http;

    let uri_str = format!(
        "{}/api/v1/repositories/{repo}/validate",
        configuration.base_path,
        repo = crate::apis::urlencode(p_path_repo)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_password {
        req_builder = req_builder.query(&[("password", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ssh_private_key {
        req_builder = req_builder.query(&[("sshPrivateKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_insecure {
        req_builder = req_builder.query(&[("insecure", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tls_client_cert_data {
        req_builder = req_builder.query(&[("tlsClientCertData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tls_client_cert_key {
        req_builder = req_builder.query(&[("tlsClientCertKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enable_oci {
        req_builder = req_builder.query(&[("enableOci", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_github_app_private_key {
        req_builder = req_builder.query(&[("githubAppPrivateKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_github_app_id {
        req_builder = req_builder.query(&[("githubAppID", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_github_app_installation_id {
        req_builder = req_builder.query(&[("githubAppInstallationID", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_github_app_enterprise_base_url {
        req_builder =
            req_builder.query(&[("githubAppEnterpriseBaseUrl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_proxy {
        req_builder = req_builder.query(&[("proxy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_gcp_service_account_key {
        req_builder = req_builder.query(&[("gcpServiceAccountKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_http_basic_auth {
        req_builder = req_builder.query(&[("forceHttpBasicAuth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_azure_workload_identity {
        req_builder = req_builder.query(&[("useAzureWorkloadIdentity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_bearer_token {
        req_builder = req_builder.query(&[("bearerToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_insecure_oci_force_http {
        req_builder = req_builder.query(&[("insecureOciForceHttp", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceValidateAccessError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn repository_service_validate_write_access(
    configuration: &configuration::Configuration,
    body: &str,
    repo: &str,
    username: Option<&str>,
    password: Option<&str>,
    ssh_private_key: Option<&str>,
    insecure: Option<bool>,
    tls_client_cert_data: Option<&str>,
    tls_client_cert_key: Option<&str>,
    r#type: Option<&str>,
    name: Option<&str>,
    enable_oci: Option<bool>,
    github_app_private_key: Option<&str>,
    github_app_id: Option<&str>,
    github_app_installation_id: Option<&str>,
    github_app_enterprise_base_url: Option<&str>,
    proxy: Option<&str>,
    project: Option<&str>,
    gcp_service_account_key: Option<&str>,
    force_http_basic_auth: Option<bool>,
    use_azure_workload_identity: Option<bool>,
    bearer_token: Option<&str>,
    insecure_oci_force_http: Option<bool>,
) -> Result<serde_json::Value, Error<RepositoryServiceValidateWriteAccessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_repo = repo;
    let p_query_username = username;
    let p_query_password = password;
    let p_query_ssh_private_key = ssh_private_key;
    let p_query_insecure = insecure;
    let p_query_tls_client_cert_data = tls_client_cert_data;
    let p_query_tls_client_cert_key = tls_client_cert_key;
    let p_query_type = r#type;
    let p_query_name = name;
    let p_query_enable_oci = enable_oci;
    let p_query_github_app_private_key = github_app_private_key;
    let p_query_github_app_id = github_app_id;
    let p_query_github_app_installation_id = github_app_installation_id;
    let p_query_github_app_enterprise_base_url = github_app_enterprise_base_url;
    let p_query_proxy = proxy;
    let p_query_project = project;
    let p_query_gcp_service_account_key = gcp_service_account_key;
    let p_query_force_http_basic_auth = force_http_basic_auth;
    let p_query_use_azure_workload_identity = use_azure_workload_identity;
    let p_query_bearer_token = bearer_token;
    let p_query_insecure_oci_force_http = insecure_oci_force_http;

    let uri_str = format!(
        "{}/api/v1/write-repositories/{repo}/validate",
        configuration.base_path,
        repo = crate::apis::urlencode(p_path_repo)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_password {
        req_builder = req_builder.query(&[("password", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ssh_private_key {
        req_builder = req_builder.query(&[("sshPrivateKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_insecure {
        req_builder = req_builder.query(&[("insecure", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tls_client_cert_data {
        req_builder = req_builder.query(&[("tlsClientCertData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tls_client_cert_key {
        req_builder = req_builder.query(&[("tlsClientCertKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enable_oci {
        req_builder = req_builder.query(&[("enableOci", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_github_app_private_key {
        req_builder = req_builder.query(&[("githubAppPrivateKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_github_app_id {
        req_builder = req_builder.query(&[("githubAppID", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_github_app_installation_id {
        req_builder = req_builder.query(&[("githubAppInstallationID", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_github_app_enterprise_base_url {
        req_builder =
            req_builder.query(&[("githubAppEnterpriseBaseUrl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_proxy {
        req_builder = req_builder.query(&[("proxy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_gcp_service_account_key {
        req_builder = req_builder.query(&[("gcpServiceAccountKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_http_basic_auth {
        req_builder = req_builder.query(&[("forceHttpBasicAuth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_azure_workload_identity {
        req_builder = req_builder.query(&[("useAzureWorkloadIdentity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_bearer_token {
        req_builder = req_builder.query(&[("bearerToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_insecure_oci_force_http {
        req_builder = req_builder.query(&[("insecureOciForceHttp", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RepositoryServiceValidateWriteAccessError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
